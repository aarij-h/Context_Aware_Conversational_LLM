# -*- coding: utf-8 -*-
"""main.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-D8KVAgIqNVyQwa5Q_GVqKGVu3E5bYwg
"""

import cohere
from langchain_cohere import ChatCohere
from langchain_huggingface import HuggingFaceEmbeddings
from langchain_community.vectorstores import Qdrant
from langchain.memory import ConversationBufferMemory
from langchain.chains import ConversationalRetrievalChain
from langchain.schema import Document
import pandas as pd
from qdrant_client import QdrantClient
from qdrant_client.models import Distance, VectorParams
from flask import Flask, request, jsonify
from pyngrok import ngrok
import threading

# Load your CSV
df = pd.read_csv("C:/Users/Aarij hussain/Downloads/BigBasketProducts.csv")

# Convert each row into a LangChain Document by combining all columns
docs = []
for _, row in df.iterrows():
    content = f"Product: {row['product']}, Category: {row['category']}"
    docs.append(Document(page_content=content))

# Creating embeddings model
embedding_model = HuggingFaceEmbeddings(
    model_name='sentence-transformers/all-MiniLM-L6-v2',
    model_kwargs={'device': 'cpu'}  # or 'cuda' if you have GPU
)

# Creating Qdrant vector store (in-memory)
qdrant = Qdrant.from_documents(
    documents=docs,
    embedding=embedding_model,
    location=":memory:",
    collection_name="products"
)

# Initializing LangChain-compatible Cohere LLM
llm = ChatCohere(cohere_api_key="API KEY TO BE INSERTED", model="command-r-plus")

# Setting up memory to keep track of conversation history
memory = ConversationBufferMemory(
    memory_key="chat_history",
    input_key="question",
    output_key="answer",
    return_messages=True
)

# Creating the retrieval chain
chain = ConversationalRetrievalChain.from_llm(
    llm=llm,
    retriever=qdrant.as_retriever(),
    memory=memory
)

# Flask setup
app = Flask(__name__)

@app.route('/ask', methods=['POST'])
def ask_question():
    user_input = request.json['user_input']
    result = chain.invoke({"question": user_input})
    return jsonify({"response": result["answer"]})

if __name__ == '__main__':
    app.run(debug=True)

